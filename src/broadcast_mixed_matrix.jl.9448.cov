        - #####################################################
        - # Inferrability of mixed matrices during broadcasting
        - #####################################################
        - # Types and traits are defined in 'io_traits_conversion'
        - # These definitions tells the compiler more type
        - # details in advance of mapping or broadcasting.
        - 
        - # Overload MixedMatrices - numer of axes always 2
      271 function Broadcast.BroadcastStyle(::Type{ArrayPartition{T,S}}) where {T, S<:NTuple{N, RW(N)} where N}
      271     ArrayPartitionStyle(Base.Broadcast.DefaultArrayStyle{2}())
        - end
        - 
       45 @inline combine_styles(A::MixedCandidate, B::AbstractMatrix) = _combine_styles(mixed_array_trait(A), A, B)
        1 @inline combine_styles(A::AbstractMatrix, B::MixedCandidate) = _combine_styles(mixed_array_trait(B), B, A)
       46 @inline _combine_styles(::MatSqMut, A, _) = combine_styles(A)
        - @inline _combine_styles(::Mixed, A, B) = combine_styles(A)                       # Fallback
        - 
      256 @inline function Base.copy(bc::Broadcast.Broadcasted{ArrayPartitionStyle{Base.Broadcast.DefaultArrayStyle{2}}})
      791     @inline function outer(i)
      963         copy(broadcasted(bc.f, unpack_args(i, bc.args)...))
        -     end
      457     ArrayPartition(ntuple(outer, Val(npartitions(bc))))
        - end
        - 
        - # For broadcasting mixed matrices  with normal matrices
       96 unpack(x::AbstractMatrix, i) = ArrayPartition(map(vpack, x[i, :])...)
        - 
        - 
        - ## Iterable Collection Constructs
        - # 2-argument map not inferrable. To improve on this, see the implementations for SparseArrays or StaticArrays.
        4 Base.map(f, A::MixedCandidate, B::MixedCandidate) = _map(mixed_array_trait(A),f, A, B)
        2 Base.map(f, A::MixedCandidate, B::AbstractMatrix) = _map(mixed_array_trait(A),f, A, B)
        - Base.map(f, A::AbstractMatrix, B::MixedCandidate) = _map(mixed_array_trait(B),f, A, B)
        3 function _map(::MatSqMut, f, A, B)
        3     ArrayPartition(map(zip(eachrow(A), eachrow(B))) do (rwA, rwB)
        6         maprow(f, rwA, rwB)
        -     end...)
        - end
        3 _map(::VecMut, f, iters...) = collect(Base.Generator(f, iters...))
        - 
        6 function maprow(f, rwA, rwB)
        6     ArrayPartition(map(zip(rwA, rwB)) do (a, b)
       12         vpack(f(a, b))
        -     end...)
        - end
       11 zip(A::MixedCandidate, B::AbstractMatrix) = _zip(mixed_array_trait(A), A, B)
        2 zip(A::AbstractMatrix, B::MixedCandidate) = _zip(mixed_array_trait(B), A, B)
       11 _zip(::MatSqMut, A::MixedCandidate, B) = Base.Iterators.Zip((A, transpose(B)))
        2 _zip(::MatSqMut, A, B::MixedCandidate) = Base.Iterators.Zip((transpose(A), B))
        0 _zip(::Mixed, A, B) = Base.Iterators.Zip((A, B))                   # Fallback
        - # Todo consider implementing for mixed matrices:
        - #Base.mapreduce(f,op,A::ArrayPartition) = mapreduce(f,op,(mapreduce(f,op,x) for x in A.x))
        - #Base.filter(f,A::ArrayPartition) = ArrayPartition(map(x->filter(f,x), A.x))
        - #Base.any(f,A::ArrayPartition) = any(f,(any(f,x) for x in A.x))
        - #Base.any(f::Function,A::ArrayPartition) = any(f,(any(f,x) for x in A.x))
        - #Base.any(A::ArrayPartition) = any(identity, A)
        - #Base.all(f,A::ArrayPartition) = all(f,(all(f,x) for x in A.x))
        - #Base.all(f::Function,A::ArrayPartition) = all(f,(all(f,x) for x in A.x))
        - #Base.all(A::ArrayPartition) = all(identity, A)
        - 
