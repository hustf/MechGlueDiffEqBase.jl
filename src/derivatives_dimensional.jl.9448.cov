        - ###############################
        - # Differentiation of quantities
        - ###############################
        - 
        - # The function signature in OrdinaryDiffEq.FiniteDiff is restrictive. "Real" excludes complex numbers,
        - # but that unfortunately excludes Quantity as well. A Quantity covering several types can be Real or Complex.
        - # compute_epsilon extends \FiniteDiff\src\epsilons.jl
        4 @inline function compute_epsilon(::Val{:central}, x::T, relstep::Real, absstep::Quantity{T1, D, U}, dir = nothing) where {T<:Number, T1<:Real, D, U}
        4     @debug "compute_epsilon:9 central" T x relstep absstep maxlog = 2
        5     max(relstep * abs(x), absstep)
        - end
        - 
       31 @inline function compute_epsilon(::Val{:central}, x::Quantity{T1, D, U}, relstep::Real, absstep::Real, dir = nothing) where {T1<:Real, D, U}
       31     @debug "compute_epsilon:14 central quantity" T1 x relstep absstep maxlog = 2
       45     max(relstep*abs(x), absstep * oneunit(x))
        - end
        - 
        2 @inline function compute_epsilon(::Val{:forward}, x::T, relstep::Real, absstep::Quantity{T1, D, U},
        -     dir = nothing) where {T<:Number, T1<:Real, D, U}
        2     @debug "compute_epsilon:21 forward quantity" T1 x relstep absstep maxlog = 2
        3     max(relstep * oneunit(absstep), absstep)
        - end
        - 
        1 @inline function compute_epsilon(::Val{:forward}, x::Quantity{T1, D, U}, relstep::Real, absstep::Real, dir = nothing) where {T1<:Real, D, U}
        1     @debug "compute_epsilon:26 forward quantity" T1 x relstep absstep maxlog = 2
        1     max(relstep*abs(x), absstep * oneunit(x))
        - end
        - 
        2 @inline function compute_epsilon(::Val{:complex}, x::Quantity{T, D, U}, ::Union{Nothing,T1} = nothing,
        -     ::Union{Nothing,Quantity{T, D, U}} = nothing, dir = nothing) where {T1<:Real, T<:Real, D, U}
        2     @debug "compute_epsilon:33 complex quantity" T x relstep absstep maxlog = 2
        2     eps(T)∙oneunit(x)
        - end
        - 
        1 @inline function compute_epsilon(::Val{:complex}, x::Quantity{T1, D, U}, relstep::Real, absstep::Real, dir = nothing) where {T1<:Real, D, U}
        1     @debug "compute_epsilon:38 complex quantity" x relstep absstep maxlog = 2
        1     eps(T1)∙oneunit(x)
        - end
        - 
        - ##############################
        - # (Updating) Jacobian matrices
        - # with mixed element types
        - ##############################
        - 
        - # From FiniteDiff\src\derivatives.jl:4.
       15 function finite_difference_derivative(
        -     f,
        -     x::T,
        -     fdtype = Val(:central),
        -     returntype = eltype(ustrip(x)),
        -     f_x = nothing;
        -     relstep = default_relstep(fdtype, T),
        -     absstep = relstep * oneunit(x),
        -     dir = true) where {T<:Quantity}
        - 
        5     fdtype isa Type && (fdtype = fdtype())
        7     epsilon = compute_epsilon(fdtype, x, relstep, absstep, dir)
        - 
        5     if fdtype == Val(:forward)
        1         return (f(x+epsilon) - f(x)) / epsilon
        4     elseif fdtype == Val(:central)
        3         return (f(x+epsilon) - f(x-epsilon)) / (2*epsilon)
        1     elseif fdtype == Val(:complex) && returntype<:Real
        1         return imag(f(x+im*epsilon)) / epsilon
        -     end
        0     fdtype_error(returntype)
        - end
        - 
        - 
