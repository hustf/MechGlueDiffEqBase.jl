        - using NLsolve: AbstractSolverCache
        - """
        -     LenNTRCache <: AbstractSolverCache
        - 
        -     Type lenient NewtonTrustRegionCache. Fieldnames:
        - 
        -     x::Tx         # Current point
        -     xold::Tx      # Old point
        -     r::TF         # Current residual
        -     r_predict::TF # Predicted residual
        -     p             # Step, dimensionless
        -     p_c::Tx       # Cauchy point, dimensionless
        -     pi            # Gauss-Newton step, dimensionless
        -     d             # Scaling vector, dimensionless
        - """
        - struct LenNTRCache{Tx, TF, T} <: AbstractSolverCache
       18     x::Tx
        -     xold::Tx
        -     r::TF
        -     r_predict::TF
        -     p::T
        -     p_c::T
        -     pi::T
        -     d::T
        - end
        9 function LenNTRCache(df)
        9     x = copy(df.x_f)
        9     xold = copy(x)
        9     r = copy(df.F)
        9     r_predict = copy(r)
        9     p = ustrip(copy(x))
        9     p_c = ustrip(copy(x))
        9     pi = ustrip(copy(x))
        9     d = ustrip(copy(x))
        9     LenNTRCache(x, xold, r, r_predict, p, p_c, pi, d)
        - end
        - 
        6 function trust_region_(df::OnceDifferentiable,
        -     initial_x::AbstractArray{Tx},
        -     xtol::T,
        -     ftol::T,
        -     iterations::Integer,
        -     store_trace::Bool,
        -     show_trace::Bool,
        -     extended_trace::Bool,
        -     factor::Real,
        -     autoscale::Bool,
        -     cache = LenNTRCache(df)) where {Tx, T}
        - 
        - 
        - 
        6     copyto!(cache.x, initial_x)
        6     value_jacobian!!(df, cache.x)
        6     cache.r .= NLsolve.value(df)
        6     @debug "trust_region_:54 LenNTRCache evaluated at " string(initial_x) string(df.F) string(df.DF) string(cache.r) string(cache.d) Tx T maxlog = 2
        - 
        6     NLsolve.check_isfinite(cache.r)
        - 
        6     it = 0
        6     x_converged, f_converged = assess_convergence(ustrip(initial_x), ustrip(cache.xold), ustrip(NLsolve.value(df)), NaN, ftol)
        - 
        6     stopped = any(isnan, cache.x) || any(isnan, NLsolve.value(df)) ? true : false
        - 
        6     converged = x_converged || f_converged
        - 
        6     delta = convert(real(T), NaN)
        6     rho = convert(real(T), NaN)
        6     @debug "trust_region_:68" converged delta rho maxlog = 2
        6     if converged
        0         tr = NLsolve.SolverTrace()
        0         name = "Trust-region with dogleg"
        0         if autoscale
        0             name *= " and autoscaling"
        -         end
        0         return SolverResultsDimensional(name,
        -             initial_x, copy(cache.x), norm(cache.r, Inf),
        -             it, x_converged, xtol, f_converged, ftol, tr,
        -             first(df.f_calls), first(df.df_calls))
        -     end
        - 
        6     tr = NLsolve.SolverTrace()
       12     tracing = store_trace || show_trace || extended_trace
        6     NLsolve.@trustregiontrace convert(real(T), NaN)
        6     nn = length(cache.x)
        6     if autoscale
        6         J = NLsolve.jacobian(df)
       12         for j = 1:nn
       18             cache.d[j] = norm(view(ustrip(J), :, j))
       12             @debug "trust_region_:88" it j cache.d[j] string(J)
       24             if cache.d[j] == zero(cache.d[j])
        0                 cache.d[j] = one(cache.d[j])
        -             end
       18         end
        -     else
        0         throw("hardly yet")
        -         # oneunit.(ArrayPartition(4.338005808987156kg, 1.4s))
        - 
        0         fill!(cache.d, one(real(T)))
        -     end
        6     @debug "trustregion_:100" string(cache.d) string(cache.x)
        6     delta = factor * NLsolve.wnorm(cache.d ./ oneunit.(cache.d), cache.x ./ oneunit.(cache.x))
        6     @debug "trustregion_" it T delta
        6     if delta == zero(delta)
        0         delta = factor
        -     end
        - 
        6     eta = convert(real(T), 1e-4)
        - 
       36     while !stopped && !converged && it < iterations
       30         it += 1
        - 
       30         @debug "trustregion_:115" it T delta string(cache.p) string(cache.p_c) string(cache.r) string(cache.d)
        -         # Compute proposed iteration step
       30         dogleg_dimensional!(cache.p, cache.p_c, cache.pi, cache.r, cache.d, NLsolve.jacobian(df), delta)
       30         copyto!(cache.xold, cache.x)
       30         cache.x .+= cache.p .* unit.(cache.x)
       30         @debug "trustregion_:117" it string(cache.x) maxlog = 10
        - 
       30         NLsolve.value!(df, cache.x)
       30         @debug "trustregion_:120" string(cache.r_predict) string(NLsolve.jacobian(df)) string(cache.p) maxlog = 1
        -         # Ratio of actual to predicted reduction (equation 11.47 in N&W)
        -         #mul!(vec(cache.r_predict), NLsolve.jacobian(df), vec(cache.p))
       30         mul!(cache.r_predict, NLsolve.jacobian(df), cache.p .* unit.(cache.x))
       30         @debug "trustregion_:124" string(cache.r_predict) string(cache.r)
       30         cache.r_predict .+= cache.r
       30         @debug "trustregion_:126"  rho sum(UNITLESS_ABS2, cache.r) 
       30         @debug "trustregion_:127"  sum(UNITLESS_ABS2, NLsolve.value(df))
       30         @debug "trustregion_:128" sum(UNITLESS_ABS2, cache.r) 
       30         @debug "trustregion_:129" sum(UNITLESS_ABS2, cache.r_predict)
       30         @debug "trustregion_:130" (sum(UNITLESS_ABS2, cache.r) - sum(UNITLESS_ABS2, cache.r_predict))
       30         @debug "trustregion_:131" (sum(UNITLESS_ABS2, cache.r) - sum(UNITLESS_ABS2, NLsolve.value(df)))
        -         #rho = (sum(abs2, cache.r) - sum(abs2, NLsolve.value(df))) / (sum(abs2, cache.r) - sum(abs2, cache.r_predict))
       30         rho = (sum(UNITLESS_ABS2, cache.r) - sum(UNITLESS_ABS2, NLsolve.value(df))) / (sum(UNITLESS_ABS2, cache.r) - sum(UNITLESS_ABS2, cache.r_predict))
       30         @debug "trustregion_:134" it T rho eta
       30         if rho > eta
        -             # Successful iteration
       30             @debug "trustregion_:137 success" 
       30             cache.r .= NLsolve.value(df)
       30             @debug "trustregion_:139 update jacobian" 
       30             NLsolve.jacobian!(df, cache.x)
       30             @debug "trustregion_:139 update scaling " 
        -             # Update scaling vector
       30             if autoscale
       60                 for j = 1:nn
        -                     #cache.d[j] = max(convert(real(T), 0.1) * real(cache.d[j]), norm(view(NLsolve.jacobian(df), :, j)))
        -                     # cache.d[j] = norm(view(ustrip(J), :, j))
       90                     cache.d[j] = max(convert(real(T), 0.1) * real(cache.d[j]), ODE_DEFAULT_NORM(view(NLsolve.jacobian(df), :, j), 2))
       60                     @debug "trustregion_:148 norm col $j " ODE_DEFAULT_NORM(view(NLsolve.jacobian(df), :, j), 0)
       90                 end
        -             end
       30             @debug "trustregion_:151"
       30             x_converged, f_converged = assess_convergence(ustrip(cache.x), ustrip(cache.xold), ustrip(cache.r), xtol, ftol)
       30             @debug "trustregion_:153"
       30             converged = x_converged || f_converged
        -         else
        0             cache.x .-= cache.p
        0             x_converged, converged = false, false
        -         end
        - 
       30         NLsolve.@trustregiontrace euclidean(cache.x, cache.xold)
        - 
        -         # Update size of trust region
       30         if rho < 0.1
        0             delta = delta/2
       30         elseif rho >= 0.9
       30             delta = 2 * NLsolve.wnorm(cache.d, cache.p)
        0         elseif rho >= 0.5
        0             delta = max(delta, 2 * NLsolve.wnorm(cache.d, cache.p))
        -         end
       30         stopped = any(isnan, cache.x) || any(isnan, NLsolve.value(df)) ? true : false
       30     end
        - 
        6     name = "Trust-region with dogleg"
        6     if autoscale
        6         name *= " and autoscaling"
        -     end
        6     @debug "trustregion_:177 method" name 
        6     @debug "trustregion_:178 inital_x" string(ustrip.(initial_x))
        6     @debug "trustregion_:179 zero" string(ustrip.(copy(cache.x)))
        6     @debug "trustregion_:180" it
        6     @debug "trustregion_:181" x_converged
        6     @debug "trustregion_:182" xtol
        6     @debug "trustregion_:183" f_converged
        6     @debug "trustregion_:184" ftol
        6     @debug "trustregion_:185" tr 
        - 
        -     #
        - 
        -     # TODO: create new type for results, implement `zero` and 'show'. Also check NLSolversBase for other methods.
        -     #  rT<:Real,T<:Union{rT,Complex{rT}},I<:AbstractArray{T},Z<:AbstractArray{T}
        6     return SolverResultsDimensional(name,            # method::String
        -             initial_x,                            # initial_x::I
        -             copy(cache.x),                        # zero::Z
       24             maximum(x-> abs(ustrip(x)), cache.r), # residual_norm::rT
        -             it,                                   # iterations::Int
        -             x_converged,                          # x_converged::Bool
        -             xtol,                                 # xtol::rT
        -             f_converged,                          # f_converged::Bool
        -             ftol,                                 # ftol::rT
        -             tr,                                   # trace::SolverTrace
        -             first(df.f_calls),                    # f_calls::Int
        -             first(df.df_calls))                   # g_calls::Int
        - #            return SolverResults(name,
        - #            initial_x, copy(cache.x), maximum(abs, cache.r),
        - #            it, x_converged, xtol, f_converged, ftol, tr,
        - #            first(df.f_calls), first(df.df_calls))     
        - end
        6 function trust_region(df::OnceDifferentiable,
        -     initial_x::RW(N),
        -     xtol::Real,
        -     ftol::Real,
        -     iterations::Integer,
        -     store_trace::Bool,
        -     show_trace::Bool,
        -     extended_trace::Bool,
        -     factor::Real,
        -     autoscale::Bool) where N
        6     cache = LenNTRCache(df)
        6     @debug "trust_region:187 LenNTRCache" xtol ftol string(initial_x) iterations factor N maxlog = 2
        6     trust_region_(df, initial_x, xtol, ftol, iterations, store_trace, show_trace, extended_trace,
        -         convert(numtype(xtol), factor), autoscale, cache)
        - end
        - 
        - 
       30 function dogleg_dimensional!(p, p_c, p_i,
        -                  r, d, J, delta::Real)
       30     T = eltype(d)
       30     @debug "dogleg_dimensional!:188" string(p) string(p_c) string(p_i) string(r) string(d) string(J) delta maxlog = 2
        -     # TODO do this in-place. Propagate errors like commented below.
        -     #try
       30         copyto!(p_i, ustrip.(J \ r))# Gauss-Newton step
        -     #catch e
        -     #    if isa(e, LAPACKException) || isa(e, SingularException)
        -             # If Jacobian is singular, compute a least-squares solution to J*x+r = 0
        -     #        U, S, V = svd(convert(Matrix{T}, J)) # Convert to full matrix because sparse SVD not implemented as of Julia 0.3
        -     #        k = sum(S .> eps())
        -     #        mrinv = V * Matrix(Diagonal([1 ./ S[1:k]; zeros(eltype(S), length(S)-k)])) * U' # Moore-Penrose generalized inverse of J
        -     #        vecpi = vec(p_i)
        -     #        mul!(vecpi,mrinv,vec(r))
        -     #    else
        -     #        throw(e)
        -     #    end
        -     #end
       30     @debug "dogleg_dimensional!:204" string(p_i) T maxlog = 5
       30     NLsolve.rmul!(p_i, -one(T))
        - #    NLsolve.rmul!(p_i, -one(T))
        -     # Test if Gauss-Newton step is within the region
       30     if NLsolve.wnorm(d, p_i) <= delta
       26         copyto!(p, p_i)   # accepts equation 4.13 from N&W for this step
        -     else
        -         # For intermediate we will use the output array `p` as a buffer to hold
        -         # the gradient. To make it easy to remember which variable that array
        -         # is representing we make g an alias to p and use g when we want the
        -         # gradient
        -         # compute g = J'r ./ (d .^ 2)
        4         g = p
        4         @debug "dogleg_dimensional!:258" string(g) string(J) string(r)
        -         #mul!(vec(g), transpose(J), vec(r))
        4         g .= ustrip.(J \ r)
        4         @debug "dogleg_dimensional!:261" string(g)
        4         g .= g ./ d.^2
        4         @debug "dogleg_dimensional!:263" string(g) string(d)
        -         # compute Cauchy point
        8         p_c .= -NLsolve.wnorm(d, g)^2 / UNITLESS_ABS2(ustrip(J) * g) .* g
        4         @debug "dogleg_dimensional!:266" string(p_c) delta NLsolve.wnorm(d, p_c)
        4         if NLsolve.wnorm(d, p_c) >= delta
        -             # Cauchy point is out of the region, take the largest step along
        -             # gradient direction
        4             NLsolve.rmul!(g, -delta/NLsolve.wnorm(d, g))
        - 
        -             # now we want to set p = g, but that is already true, so we're done
        - 
        -         else
        -             # from this point on we will only need p_i in the term p_i-p_c.
        -             # so we reuse the vector p_i by computing p_i = p_i - p_c and then
        -             # just so we aren't confused we name that p_diff
        0             p_i .-= p_c
        0             p_diff = p_i
        - 
        -             # Compute the optimal point on dogleg path
        0             b = 2 * NLsolve.wdot(d, p_c, d, p_diff)
        0             a = NLsolve.wnorm(d, p_diff)^2
        0             tau = (-b + sqrt(b^2 - 4a*(NLsolve.wnorm(d, p_c)^2 - delta^2)))/(2a)
        0             p_c .+= tau .* p_diff
        0             copyto!(p, p_c)
        -         end
        -     end
        - end
