        - ###############
        - # Types, traits
        - ###############
        - 
        - # We want to specialize on ArrayPartitions that
        - # - can represent square matrices
        - # - are mutable
        - # - have width and height > 1
        - # - have elements that are Real, Complex, Quantity{<:Real}, Quantity{<:Complex}
        - # - are inferrable
        - # ...because Matrix{Any} is mostly not inferrable. For inferrability, we implement
        - # such matrix-like objects as nested ArrayPartition.
        - # For mutability, the innermost type is a one-element vector.
        - # A value (consider Float64):
        - const Q = Number
        - "A mutable element Vector{<:Q}"
        - const E = Vector{<:Q}
        - """
        -     RW(N) = ArrayPartition{<:Q, <:NTuple{N, E}}
        - Shorthand 'meta function'
        - Example
        - 
        -     foo(v::RW(N)) where N = 1
        - """
        2 const RW(N) = ArrayPartition{<:Q, <:NTuple{N, E}}
        - 
        - """
        - This imperfect definition of objects we want to dispatch on includes immutable
        - versions and empty tuples. It dispatches a bit too widely (includes empty tuples),
        - so we use traits-based dispatch with this type:
        - """
        - const MatrixMixedCandidate = ArrayPartition{<:Q, <:NTuple{N, RW(N)}} where {N}
        - const MixedContent(N) = ArrayPartition{<:Q, <:NTuple{N, Union{RW(N), E}}}
        - const MixedCandidate = MixedContent(N) where {N}
        - # Traits are concrete types <: Mixed
        - abstract type Mixed end
       64 struct MatSqMut <: Mixed end
       39 struct VecMut <: Mixed end
        8 struct NotMixed <: Mixed end
        4 struct Single <: Mixed end
        4 struct Empty <: Mixed end
        - const UnionVecSqMut = Union{VecMut, MatSqMut}
        - # The trait function returns a concrete type for the trait.
        4 mixed_array_trait(::T) where {T<:AbstractArray} = NotMixed()             # Fallback
        6 mixed_array_trait(::ArrayPartition{Union{}, Tuple{}}) = Empty()          # Covers N = 0, see https://docs.julialang.org/en/v1/manual/methods/#Tuple-and-NTuple-arguments
    13512 mixed_array_trait(::ArrayPartition{<:Q, <:NTuple{N, RW(N)}}) where {N} = MatSqMut()
        - #mixed_array_trait(::ArrayPartition{<:Q, <:NTuple{1, RW(1)}}) = Single()  # Covers N = 1
     5503 mixed_array_trait(::ArrayPartition{<:Q, <:NTuple{N, E}}) where {N} = N == 1 ? Single() : VecMut()
        - # Same as above, but called with `typeof(A)`. USeful because Julia base use this way of calling in IndexStyle()
        3 mixed_array_trait(::Type{<:AbstractArray}) = NotMixed()             # Fallback
        3 mixed_array_trait(::Type{<:ArrayPartition{Union{}, Tuple{}}}) = Empty()          # Covers N = 0, see https://docs.julialang.org/en/v1/manual/methods/#Tuple-and-NTuple-arguments
       11 mixed_array_trait(::Type{<:ArrayPartition{<:Q, <:NTuple{N, RW(N)} where {N}}}) = MatSqMut()
        - #mixed_array_trait(::Type{<:ArrayPartition{<:Q, <:NTuple{1, RW(1)}}}) = Single()  # Covers N = 1
        6 mixed_array_trait(::Type{<:ArrayPartition{<:Q, <:NTuple{N, E}}}) where {N} = N == 1 ? Single() : VecMut()
        - 
      112 is_square_matrix_mutable(M) = mixed_array_trait(M) isa MatSqMut
       72 is_vector_mutable_stable(v) = mixed_array_trait(v) isa VecMut
        - 
        - 
        - ############
        - # Conversion
        - ############
      765 vpack(x) = [x]
       74 vpack(x::DimensionlessQuantity) = [uconvert(NoUnits, x)]
        3 function vpack(x::AbstractVector)
        3     @assert length(x) == 1
        3     vpack(first(x))
        - end
        - 
        - """
        -     convert_to_mixed(x...)
        -     -> nested mutable ArrayPartition (Mixed).
        -     Vector-like or Matrix-like depending on input.
        - """
       84 function convert_to_mixed(A::AbstractArray)
       84     if ndims(A) == 2
       84         @assert size(A)[1] > 1 "Cannot convert to mixed from row vectors"
       83         Am = convert_to_mixed(eachrow(A))
       83         @assert Am isa MixedCandidate "Cannot convert_to_mixed from size $(size(A)) $(typeof(A))"
       83         @assert mixed_array_trait(Am) == MatSqMut()
       83         Am
        0     elseif ndims(A) == 1
        -         # Not tested, vector types are expected to dispatch elsewhere.
        0         convert_to_mixed(A...)
        -     else
        0         throw(DimensionMismatch())
        -     end
        - end
       48 convert_to_mixed(x::AbstractVector{T}) where T = convert_to_mixed(x...)
        3 convert_to_mixed(x::NTuple{N, U}) where {N, U} = ArrayPartition_from_single_element_vectors(vpack.(x))
      239 function convert_to_mixed(x::Vararg{<:Number})
      239     p = vpack.(x)
      239     if length(x) > 1
      238         ArrayPartition_from_single_element_vectors(convert.(E, p))
        -     else
        1         if length(first(p)) == 1
        1             ArrayPartition_from_single_element_vectors(p)
        -         else
        0             convert_to_mixed(p...)
        -         end
        -     end
        - end
       87 function convert_to_mixed(x::MixedCandidate)
       87     @assert is_square_matrix_mutable(x) || is_vector_mutable_stable(x)
       87     x
        - end
        1 function convert_to_mixed(A::Transpose{T, <:ArrayPartition}) where T
        1     apa = convert_to_array(A.parent)
        1     convert_to_mixed(copy(transpose(apa))) # Copy removes laziness
        - end
        - # For inferrable matrix-like
       83 function convert_to_mixed(g::Base.Generator)
      268     thismixed(rw) = convert_to_mixed(rw...)
       83     ArrayPartition(thismixed.(g)...)
        - end
      242 ArrayPartition_from_single_element_vectors(x::NTuple{N, E}) where N = ArrayPartition(x)
        - 
        - """
        -     convert_to_array(A::ArrayPartition)
        -     --> Matrix{Any} or Vector{Any}.
        - 
        - We avoid overloading base function ´convert´on types defined by ArrayTools.
        - 
        -     # Examples
        -     ```julia-repl
        -     julia> M2u = ArrayPartition(ArrayPartition([1]kg, [2]s), ArrayPartition([3]s, [4]kg));
        - 
        -     julia> convert_to_array(M2u)
        - 
        -     julia> Vu = ArrayPartition([1.0]s⁻¹, [2.0]s⁻²)
        - 
        -     julia> convert_to_array(Vu)
        - 
        -     ```
        - Note the row-first order of M2:
        - # Example
        - ```julia-repl
        - julia> reshape(convert(Array{Any}, M2), (2, 2))'
        - ```
        - 
        - """
        - convert_to_array(A::Array) = A
     6537 convert_to_array(A) = convert_to_array(mixed_array_trait(A), A)
        - 
     6535 function convert_to_array(::MatSqMut, A::ArrayPartition{T, S}) where {T, S}
     6535     m = length(A.x)
     6535     n = length(A.x[1])
     6535     X = Array{T, 2}(undef, m, n)
     6535     for i = 1:m
        -         # Square. Can easily be dropped to extend functionality.
    29235         @assert n == length(A.x[i])
    58470         for j = 1:n
   187937             X[i, j] = A.x[i][j]
   279803         end
    51935     end
     6535     X
        - end
        1 function convert_to_array(::VecMut, A::ArrayPartition{T, S}) where {T, S}
        1     Vector{T}(A)
        - end
        1 function convert_to_array(::NotMixed, A::Transpose{T, <:ArrayPartition}) where {T}
        1     apa = convert_to_array(A.parent)
        1     copy(transpose(apa)) # Copy removes laziness
        - end
        - function convert_to_array(::Mixed, A)
        -     throw(InexactError(:convert_to_array, Array, A))
        -     A
        - end
        - ##########
        - # Indexing
        - ##########
     6466 size(A::MatrixMixedCandidate) = size_of_mixed(A, mixed_array_trait(A))
     6466 size_of_mixed(A, ::MatSqMut) = size(convert_to_array(A))
        - size_of_mixed(A, ::T) where {T<:Mixed } = (length(A),)
        - size(A::AdjOrTransAbsVec{T,S}) where {T, S <: MatrixMixedCandidate} = reverse(size(A.parent))
        1 ndims(A::MatrixMixedCandidate) = ndims_of_mixed(A, mixed_array_trait(A))
        1 ndims_of_mixed(::MatrixMixedCandidate, ::MatSqMut) = 2
        - ndims_of_mixed(::AbstractArray{T,N}, ::S) where {T, N, S<:Mixed } = N
      211 axes(A::AdjOrTransAbsVec{T,S}) where {T, S <: MatrixMixedCandidate} = reverse(axes(A.parent))
        - 
        - # getindex
      193 Base.@propagate_inbounds function getindex(A::AdjOrTransAbsVec{T,S}, i::Int, j::Int) where {T, S <: MixedCandidate}
      193     @debug "getindex " S i j mixed_array_trait(A.parent)
      193     getindex_of_transposed_mixed(mixed_array_trait(A.parent), A, i, j)
        - end
      193 getindex_of_transposed_mixed(::MatSqMut, A, i, j ) = A.parent[j, i]
        - function getindex_of_transposed_mixed(::VecMut, A, i, j )
        -     @assert i == 1
        -     A.parent[j]
        - end
        - getindex_of_transposed_mixed(::S, A, i, j) where {S<:Mixed } = throw_boundserror(A, (i, j))
        - 
        - 
        - # setindex!
        - Base.@propagate_inbounds function setindex!(A::AdjOrTransAbsVec{T,S}, v, i::Int, j::Int) where {T, S <: MixedCandidate}
        -     @debug "setindex! " v i j S mixed_array_trait(A.parent)
        -     setindex!_of_transposed_mixed(mixed_array_trait(A.parent), A, v, i, j)
        - end
        - setindex!_of_transposed_mixed(::MatSqMut, A, v, i, j ) = setindex!(A.parent, v, j, i)
        - function setindex!_of_transposed_mixed(::VecMut, A, v, i, j )
        -     @assert i == 1
        -     setindex!(A.parent, v, j)
        - end
        - setindex!_of_transposed_mixed(::S, A, v, i, j) where {S<:Mixed } = throw_boundserror(A, (i, j))
        - 
        - # index style
        - # Because: IndexStyle(transpose(typeof([1 2;3 4]))) -> IndexCartesian()
        - # This is (likely) used by the fallback `show`` methods
        - function _IndexStyle(::Type{<:AdjOrTransAbsVec{T,S} where {T, S <: MixedCandidate}})
        -     @debug "_IndexStyle"
        -     throw("Unused?")
        -     IndexStyle_of_transposed_mixed(mixed_array_trait(A.parent))
        - end
        - IndexStyle_of_transposed_mixed(::MatSqMut) = IndexCartesian()
        - IndexStyle_of_transposed_mixed(::S) where {S<:Mixed} = IndexLinear()
        - 
        - 
        - ##########################
        - # IO nested ArrayPartition
        - ##########################
        - 
        - 
        - ######################################################
        - # Un-decorated (parseable) representation, trait-based
        - ######################################################
        6 print(io::IO, A::MixedCandidate) =  print_as_mixed(io, mixed_array_trait(A), A)
        4 function print_as_mixed(io::IO, ::MatSqMut, A)
        4     X = convert_to_array(A)
        8     col = get(io, :unitsymbolcolor, :cyan)
        4     buf = IOBuffer()
        4     ioc = IOContext(buf, IOContext(io).dict)
        4     printstyled(ioc, color = col, "convert_to_mixed(")
        4     prefix = String(take!(buf))
        4     printstyled(ioc, color = col, ")")
        4     postfix = String(take!(buf))
        4     if isempty(X)
        0         Base._show_empty(io, X)
        -     else
        4         Base._show_nonempty(io, X, prefix)
        4         print(io, postfix)
        -     end
        - end
        1 function print_as_mixed(io::IO, ::VecMut, v::RW(N)) where N
        -     # A normal vector would have no type info here. We provide a short summary with coloured
        -     # highlighting to indicate that this is not a quite normal vector.
        1     buf = IOBuffer()
        1     ioc = IOContext(buf, IOContext(io).dict)
        2     col = get(ioc, :unitsymbolcolor, :cyan)
        -     #printstyled(ioc, color = col, "$N-element mutable ")
        -     #print(ioc, "ArrayPartition(")
        1     printstyled(ioc, color = col, "convert_to_mixed(")
        1     prefix = String(take!(buf))
        1     printstyled(ioc, color = col, ")")
        1     postfix = String(take!(buf))
        1     Base.show_vector(io::IO, v, prefix, postfix)
        - end
        - 
        - function print_as_mixed(io::IO, ::Single, v)
        -     # A normal vector would have no type info here. We provide a short summary with coloured
        -     # highlighting to indicate that this is not a quite normal vector.
        -     buf = IOBuffer()
        -     ioc = IOContext(buf, IOContext(io).dict)
        -     col = get(ioc, :unitsymbolcolor, :cyan)
        -     printstyled(ioc, color = col, "Single-element mutable matrix (discouraged) ")
        -     print(ioc, "ArrayPartition(ArrayPartition([")
        -     prefix = String(take!(buf))
        -     Base.show_vector(io::IO, v, prefix, "]))")
        - end
        - 
        1 print_as_mixed(io::IO, ::Union{NotMixed, Empty}, v) = invoke(print, Tuple{typeof(io), Any}, io, v)
        - 
        - # Overloads RecursiveArrayTools.jl:26, which invokes showing this as 'Any'..., with too much header info:
       18 Base.show(io::IO, A::MixedCandidate) = Base.show(io, mixed_array_trait(A), A)
        5 function Base.show(io::IO, ::MatSqMut, A::MixedCandidate)
        -     # A normal matrix would have no type info here. We'll just provide a short summary with coloured
        -     # highlighting to indicate that this is not a quite normal matrix.
       10     col = get(io, :unitsymbolcolor, :cyan)
        5     printstyled(io, color = col, "convert_to_mixed(")
        5     X = convert_to_array(A)
        5     show(io, X)
        5     printstyled(io, color = col, ")")
        - end
       10 function Base.show(io::IO, ::VecMut, v::RW(N)) where N
        -     # A normal vector would have no type info here. We provide a short summary with coloured
        -     # highlighting to indicate that this is not a quite normal vector.
       10     buf = IOBuffer()
       10     ioc = IOContext(buf, IOContext(io).dict)
       50     col = get(ioc, :unitsymbolcolor, :cyan)
       10     printstyled(ioc, color = col, "$N-element mutable ")
       10     print(ioc, "ArrayPartition(")
       10     prefix = String(take!(buf))
       10     Base.show_vector(io::IO, v, prefix, ')')
        - end
        1 function Base.show(io::IO, ::Single, v)
        1     buf = IOBuffer()
        1     ioc = IOContext(buf, IOContext(io).dict)
        2     col = get(ioc, :unitsymbolcolor, :cyan)
        1     printstyled(ioc, color = col, "Single-element mutable matrix (discouraged) ")
        1     print(ioc, "ArrayPartition(ArrayPartition([")
        1     prefix = String(take!(buf))
        1     Base.show_vector(io::IO, v, prefix, "]))")
        - end
        - # Same as RecursiveArrayTools.jl:26
        2 Base.show(io::IO, ::Union{NotMixed, Empty}, A::MixedCandidate) = invoke(show, Tuple{typeof(io), Any}, io, A)
        - 
        - 
        - 
        - #########################################################
        - # Decorated (human readable) representation, trait based.
        - #########################################################
        7 summary(io::IO, A::MixedCandidate) = summary(io, mixed_array_trait(A), A)
        - # Fallback, same as Base/show.jl:2803
        - summary(io::IO, ::NotMixed, A::AbstractArray) = array_summary(io, A, axes(A))
        5 function summary(io::IO, ::MatSqMut, A)
       10     col = get(io, :unitsymbolcolor, :cyan)
        5     printstyled(io, color = col, "MatrixMixed as ")
        5     print(io, typeof(A))
        5     nothing
        - end
        1 Base.summary(io::IO, ::VecMut, ::RW(N)) where {N} = print(io, "$N-element mutable ArrayPartition")
        1 Base.summary(io::IO, ::Single, X) = print(io, "Single-element (discouraged) ArrayPartition(ArrayPartition(Vector{<:Number}))")
        - 
        8 Base.show(io::IO, m::MIME"text/plain", A::MixedCandidate) = Base.show(io, m, mixed_array_trait(A), A)
        5 function Base.show(io::IO, ::MIME"text/plain", ::MatSqMut, A::MixedCandidate)
        -     # 0) show summary before setting :compact
        5     summary(io, A)
        5     isempty(A) && return
        5     print(io, ":")
        5     Base.show_circular(io, A) && return
        5     X = convert_to_array(A)
        -     # 1) compute new IOContext
       10     if !haskey(io, :compact)
        5         io = IOContext(io, :compact => true)
        -     end
        - 
       15     if get(io, :limit, false) && displaysize(io)[1]-4 <= 0
        0         return print(io, " …")
        -     else
        5         println(io)
        -     end
        - 
        -     # 2) Don't update typeinfo (number type not shown in header)
        -     # io = IOContext(io, :typeinfo => eltype(X))
        - 
        -     # 3) show actual content
        5     recur_io = IOContext(io, :SHOWN_SET => X)
        5     Base.print_array(recur_io, X)
        - end
        1 function Base.show(io::IO, m::MIME"text/plain", ::VecMut, X::RW(N)) where N
        -     # 0) show summary before setting :compact
        1     summary(io, X)
        1     isempty(X) && return
        1     print(io, ":")
        1     Base.show_circular(io, X) && return
        - 
        -     # 1) compute new IOContext
        2     if get(io, :limit, false) && displaysize(io)[1]-4 <= 0
        0         return print(io, " …")
        -     else
        1         println(io)
        -     end
        - 
        -     # 2) Don't update typeinfo (number type not shown in header)
        -     # io = IOContext(io, :typeinfo => eltype(X))
        - 
        -     # 3) show actual content
        1     recur_io = IOContext(io, :SHOWN_SET => X)
        1     Base.print_array(recur_io, X)
        - end
        1 function Base.show(io::IO, m::MIME"text/plain", ::Single, X)
        -     # 0) show summary before setting :compact
        1     summary(io, X)
        1     isempty(X) && return
        1     print(io, ":")
        1     Base.show_circular(io, X) && return
        - 
        -     # 1) compute new IOContext
        2     if get(io, :limit, false) && displaysize(io)[1]-4 <= 0
        0         return print(io, " …")
        -     else
        1         println(io)
        -     end
        - 
        -     # 2) Don't update typeinfo (number type not shown in header)
        -     # io = IOContext(io, :typeinfo => eltype(X))
        - 
        -     # 2) show actual content
        1     recur_io = IOContext(io, :SHOWN_SET => X)
        1     Base.print_array(recur_io, X)
        - end
        - 
        - 
        - 
        - # Fallback, same as \RecursiveArrayTools\tU7uv\src\array_partition.jl:248
        1 Base.show(io::IO, m::MIME"text/plain", ::Union{NotMixed, Empty}, A::MixedCandidate) = show(io, m, A.x)
        - 
        - 
